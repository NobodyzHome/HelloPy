# 在下面这个函数中，处理入参的三个数据，并依次对这三个数据做复杂的逻辑运算(在这里用乘法代替，实际中有可能是调接口、查数据库等非常耗时的代码)。
# 一种实现方式是像下面这样，在函数中依次对这三个数据进行运算，然后一次性将计算结果返回去。这样带来的问题是调用这个函数需要花费大量时间，因为需要一次性串联执行三个复杂的业务逻辑。
def normal_function(a,b,c):
    rst=[]
    for i in (a,b,c):
        rst.append(i*5)
    return rst

# 如果数据的处理逻辑很复杂，那么调用这个函数的执行时间就会很长。因为需要等待所有的数据都处理完毕。
rst1 = normal_function(2, 3, 4)
# 输出内容：[10, 15, 20]
print(rst1)

# 生成器的实现方案
# 一种更好的方式是：
# 1.调用这个方法一次，仅处理第一个数据并返回处理结果。
# 2.再调用一次，处理第二个数据并返回处理结果。
# 3.再调用一次，处理最后一个数据并返回处理结果。
# 这样，我每次执行就处理一个数据，不会一次性串行处理多个数据，降低了单次执行的耗时。
def gen1():
    print('这是一个生成器函数')
    a, b, c = 2, 5, 30
    print('开始处理第一个数据')
    # 当第一次执行next()，会执行完下面这行代码，并返回a*3的结果
    yield a * 3
    print('开始处理第二个数据')
    # 当第二次执行next()，会从上一次之后的位置继续执行代码，直到遇到下一次yield。因此第二次执行next()，会执行完下面这行代码，并返回b*7的结果
    yield b * 7
    print('开始处理第三个数据')
    # 当第三次执行next()，会从上一次之后的位置继续执行代码，直到遇到下一次yield。因此第三次执行next()，会执行完下面这行代码，并返回c*c的结果
    yield c * c
    print('后面没有yield了，再执行next就会报错了')

# 调用包含生成器的函数，此时不会执行gen1函数里的任何代码，而是创建一个生成器对象。
# 注意：一个生成器对象，每次只能调用next()往前走，无法往回执行代码。
gen1Obj = gen1()
# 第一次执行next()，开始执行gen1函数里的代码，直到执行完第一次遇到yield的代码，就停止执行后续代码并返回处理结果了。
# 输出内容：
# 这是一个生成器函数
# 开始处理第一个数据
a1 = next(gen1Obj)
# 输出内容：a1=8
print(f'{a1=}')

# 第二次执行next()，从上一次停止的代码之后（也就是yield a*3之后）继续执行代码，直到执行完下一次yield的代码，就停止执行后续代码并返回执行结果。
# 输出内容：开始处理第二个数据
b1 = next(gen1Obj)
# 输出内容：b1=35
print(f'{b1=}')

# 第三次执行next()，从上一次停止的代码之后（也就是yield b*7之后）继续执行代码，直到执行完下一次yield的代码，就停止执行后续代码并返回执行结果。
# 输出内容：开始处理第三个数据
c1 = next(gen1Obj)
# 输出内容：c1=900
print(f'{c1=}')

# 我们尝试再一次执行next()，从上一次停止的代码之后（也就是yield c * c之后）继续执行代码，但是执行到函数结束也没有遇到yield关键字，就会报错。
# 输出内容：
# 1.先输出：后面没有yield了，再执行next就会报错了
# 2.然后报错：python-BaseException: StopIteration
# test = next(gen1Obj)

# 由于上面的报错，因此我们知道，一个生成器对象只能执行一定次数的next()。可执行的次数取决于：生成器函数中yield关键字会被执行的次数。
# 上面那个函数中，写了调用三次yield，所以生成的生成器就只能执行三次。执行第四次时就会报错。
# 所以为了避免执行next的次数超过生成器对象的限制，我们通常不手动调next()，而是使用for循环来遍历生成器对象。
# 注意：
# 由于一个生成器对象只能往前走，不能往回走。所以如果我们想从头执行生成器函数的代码，我们只能通过再调用一次生成器函数，来生成一个新的生成器对象，遍历这个新的对象。
gen1Obj2 = gen1()

# 输出内容：
# 这是一个生成器函数
# 开始处理第一个数据
# 6
# 开始处理第二个数据
# 35
# 开始处理第三个数据
# 900
# 后面没有yield了，再执行next就会报错了
for x in gen1Obj2:
    print(x)

# 在实际开发生成器函数时，往往不会向上面那样写出一行行yield语句，而是通过将yield写入到循环语句中，来实现在函数中多次执行到yield语句的效果。
def gen2(x):
    print("开始执行生成器函数：gen2")
    # 该函数中有一个for循环，将yield写入到for循环中，来实现反复执行到yield语句的效果，直至for循环执行完毕。
    times=1
    for i in range(1,x,2):
        print(f'即将遍历第{times}次')
        times+=1
        yield {i:i ** 3}

# 执行到这时不会输出任何内容，只是创建一个生成器对象
gen2_Obj1 = gen2(6)
# 输出内容：
# 开始执行生成器函数：gen2
# 即将遍历第1次
x1 = next(gen2_Obj1)
# 输出内容：x1={1: 1}
print(f'{x1=}')

# 输出内容：即将遍历第2次
x2 = next(gen2_Obj1)
# 输出内容：x2={3: 27}
print(f'{x2=}')

# 输出内容：即将遍历第3次
x3 = next(gen2_Obj1)
# 输出内容：x3={5: 125}
print(f'{x3=}')
